local Players = game:GetService("Players")
local player = Players.LocalPlayer
local camera = workspace.CurrentCamera

local CONFIG = {
    SPAM_DELAY = 0.02,
    PROCESS_DURATION = 0.3,
    CHECK_LOAD_TIME = 0,
    COOLDOWN_TIME = 10,
    STARTUP_WAIT_1 = 2,
    STARTUP_WAIT_2 = 2,
    LOAD_DISTANCE_THRESHOLD = 200,
    LOAD_WAIT_TIME = 1,
    BUTTON_MONEY_WAIT = 20,
    MAX_LONG_TELEPORTS_PER_CYCLE = 2 -- Max 2 long teleports before cooldown
}

local isRunning = false
local startupComplete = false

-- GUI Setup
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "BankAuto"
screenGui.ResetOnSpawn = false
screenGui.Parent = player:WaitForChild("PlayerGui")

local button = Instance.new("TextButton")
button.Size = UDim2.new(0, 140, 0, 50)
button.Position = UDim2.new(0, 20, 0.5, -25)
button.BackgroundColor3 = Color3.fromRGB(46, 204, 113)
button.Text = "START AUTO"
button.TextColor3 = Color3.new(1, 1, 1)
button.TextSize = 18
button.Font = Enum.Font.SourceSansBold
button.Parent = screenGui

Instance.new("UICorner", button).CornerRadius = UDim.new(0, 6)

function updateButton()
    if isRunning then
        button.BackgroundColor3 = Color3.fromRGB(231, 76, 60)
        button.Text = "STOP"
    else
        button.BackgroundColor3 = Color3.fromRGB(46, 204, 113)
        button.Text = "START AUTO"
    end
end

function resetCamera()
    camera.CameraType = Enum.CameraType.Custom
end

-- Ensure HRP exists
local function getHRP()
    local char = player.Character
    if char then
        return char:FindFirstChild("HumanoidRootPart")
    end
    return nil
end

local function ensureHRP()
    while isRunning do
        local hrp = getHRP()
        if hrp then return hrp end
        task.wait(0.1)
    end
    return nil
end

-- Track long distance teleports per cycle
local longTeleportCount = 0

-- Standard coordinate teleport (NO LIMIT CHECK - for cooldown/startup)
local function tpCoordsNoLimit(pos)
    local hrp = ensureHRP()
    if not hrp then return false end
    hrp.CFrame = CFrame.new(pos.X, pos.Y, pos.Z)
    return true
end

-- Limited teleport - counts toward 200-stud limit
local function tpCoordsLimited(pos)
    local hrp = ensureHRP()
    if not hrp then return false, "NO_HRP" end
    
    local currentPos = hrp.Position
    local distance = (currentPos - pos).Magnitude
    
    -- Check if this is a long teleport
    if distance > CONFIG.LOAD_DISTANCE_THRESHOLD then
        if longTeleportCount >= CONFIG.MAX_LONG_TELEPORTS_PER_CYCLE then
            button.Text = "LIMIT REACHED"
            return false, "LIMIT_HIT" -- Signal to go to cooldown
        end
        longTeleportCount = longTeleportCount + 1
        
        -- Wait for area to load
        button.Text = "LOADING..."
        task.wait(CONFIG.LOAD_WAIT_TIME)
    end
    
    hrp.CFrame = CFrame.new(pos.X, pos.Y, pos.Z)
    return true, "OK"
end

-- Limited teleport to part - counts toward limit
local function tpToPartLimited(part)
    local hrp = ensureHRP()
    if not hrp or not part then return false, "INVALID" end
    
    local distance = (hrp.Position - part.Position).Magnitude
    
    -- Check if this is a long teleport
    if distance > CONFIG.LOAD_DISTANCE_THRESHOLD then
        if longTeleportCount >= CONFIG.MAX_LONG_TELEPORTS_PER_CYCLE then
            button.Text = "LIMIT REACHED"
            return false, "LIMIT_HIT"
        end
        longTeleportCount = longTeleportCount + 1
    end
    
    -- Perform camera lock teleport
    hrp.CFrame = CFrame.new(part.Position + Vector3.new(0, 3, 0))
    camera.CameraType = Enum.CameraType.Scriptable
    camera.CFrame = CFrame.new(part.Position + Vector3.new(0, 4, 0), part.Position)
    
    return true, "OK"
end

local function firePrompt(prompt)
    if not prompt or not prompt:IsA("ProximityPrompt") then return end
    prompt:InputHoldBegin()
    prompt:InputHoldEnd()
end

local function spamPrompt(prompt)
    if not prompt then return end
    local start = tick()
    while isRunning and (tick() - start) < CONFIG.PROCESS_DURATION do
        firePrompt(prompt)
        task.wait(CONFIG.SPAM_DELAY)
    end
end

local function getBankButton()
    local bank = workspace:FindFirstChild("BANK")
    if not bank then return nil, nil end
    local panel = bank:FindFirstChild("ButtonPanel")
    if not panel then return nil, nil end
    local pPart = panel:FindFirstChild("PromptPart")
    if not pPart then return nil, nil end
    return pPart:FindFirstChild("ProximityPrompt"), pPart
end

local function getNearestMoney()
    local bank = workspace:FindFirstChild("BANK")
    if not bank then return nil, nil end
    local boxes = bank:FindFirstChild("MoneyBoxes")
    if not boxes then return nil, nil end
    
    local hrp = getHRP()
    if not hrp then return nil, nil end
    
    local hrpPos = hrp.Position
    local nearestPrompt, nearestPart, shortestDist = nil, nil, math.huge
    
    for _, box in ipairs(boxes:GetChildren()) do
        local pp = box:FindFirstChild("PromptPart")
        if pp then
            local prompt = pp:FindFirstChild("ProximityPrompt")
            if prompt and prompt.Enabled then
                local dist = (hrpPos - pp.Position).Magnitude
                if dist < shortestDist then
                    shortestDist = dist
                    nearestPrompt = prompt
                    nearestPart = pp
                end
            end
        end
    end
    return nearestPrompt, nearestPart
end

local function isMuseumOpen()
    local museum = workspace:FindFirstChild("MUSEUM")
    if not museum then return false end
    if museum:FindFirstChild("MuseumDoor") then
        return false
    end
    return true
end

local function getNearestArt()
    local museum = workspace:FindFirstChild("MUSEUM")
    if not museum then return nil, nil end
    local artFolder = museum:FindFirstChild("Art")
    if not artFolder then return nil, nil end
    
    local hrp = getHRP()
    if not hrp then return nil, nil end
    
    local hrpPos = hrp.Position
    local nearestPrompt, nearestPart, shortestDist = nil, nil, math.huge
    
    for _, artModel in ipairs(artFolder:GetChildren()) do
        local mainPart = artModel:FindFirstChild("MainPart")
        if mainPart then
            local prompt = mainPart:FindFirstChild("ProximityPrompt")
            if prompt and prompt.Enabled then
                local dist = (hrpPos - mainPart.Position).Magnitude
                if dist < shortestDist then
                    shortestDist = dist
                    nearestPrompt = prompt
                    nearestPart = mainPart
                end
            end
        end
    end
    return nearestPrompt, nearestPart
end

local function processTarget(part, prompt, isLimited)
    if not isRunning then return end
    
    -- Teleport with limit check if specified
    if isLimited then
        local success, status = tpToPartLimited(part)
        if not success then return false, status end
    else
        -- Unlimited (bypass counter) - not used for main targets currently
        local hrp = ensureHRP


